<!--
JS(Java Script)
html과 css로 만들어진 페이지에 동적인 움직임을 추가해주는 역할



화면을 조작하거나, 이벤트처리
데이터 처리 : 계산, 조건에 따라서 코드를 실행, 반복
서버와 통신 : API 요청으로 데이터를 주고받기
우리가 만든 기능들


html 내에서는 <script> ~ </script>를 이용하여 자바스크립트 코드 작성
head쪽 작성 : 페이지의 초기설정이 들어감
body쪽 작성 : 요소의 처리



데이터 타입
현실세계의 데이터를 디지털로 표현하기 위해 설정하나 타입
숫자 : number
문자 : string
논리 : boolean

변수 - 데이터를 저장하기 위한 컵

변수의 선언
키워드 변수명 ; => 변수를 만들되, 값은 들어있지 않은 상태

변수의 대입
변수명 = 값; => 오른쪽에 있는 데이터를 왼쪽의 변수에 대입

변수의 초기화(초기값을 넣는다)
키워드 변수명 = 값;



키워드 

var - 변수를 재선언해도 오류가 나지 않는다.(덮어쓰기가 된다)
값을 변수에 대입할 수도 있다

let - 변수를 재선언 할 수 없다. 값을 변수에 대입할 수 있다

const - 변수를 재선언할 수 없다. 항상 초기화를 해야한다
값을 다시 대입할 수 없다



타입 변환(type conversion)
어떤 타입의 데이터를 다른 타입으로 바꾸는 것
함수를 통해서 값을 강제로 다른 타입으로 바꾸는 것
연산 과정에서자연스럽게 다른 티입으로 바뀌는 것



반복문
같은 작업을 여러번 자동으로 수행하게 하는 문법

반복횟수 : 초기식의 값부터 조건식의 값 사이의 숫자의 개수



배열 : 여러개의 값을 한번에 저장할 수 있는 자료구조
배열에 들어가 있는 데이터를 요소

각 요소는 index라는 위치번호를 가짐
위치번호는 0부터 1씩 순차적 증가

배열의 생성 : let 변수명 = []; => 비어있는 배열의 생성
배열의 요소에 접근하는 법 : 변수명[index];
배열에 들어있는 내용을 출력
데이터를 대입하여 새로운 값을 넣을 수도 있다.



객체 : 현실세계에 존재하는 유형, 무형의 것을 디지털화해서 코드로 표현

객체의 생성
객체 리터럴방식 {프로퍼티 작성}

객체의 값에 접근하는 방법
변수명.키 
ㄴ 프로퍼티에 들어있는 값을 출력, 수정하는 것이 가능

객체의 프로퍼티를 추가하는 방법
변수명.새로운키 = 값;
객체에 프로퍼티가 없었다면 추가가 된다.

delete 변수명.key << 프로퍼티 삭제 

객체는 속성(상태)를 저장할 수 있고, 행동(행위)도 함수로  표현할 수 있다.
객체 안에 정의된 함수 => 메서드

함수 : 독립적으로 호출이 가능

let car = {
    drive : function(){     <== 메서드 정의
        기능
    }
} 

car.drive();    <== 메서드의 호출



DOM(Document Object Model)
브라우저가 HTML코드를 읽어서 만든 트리구조의 데이터

부모, 자식, 형제 관계가 존재

document객체
웹페이지 전체를 대표하는 최상위 객체

document 메서드로 HTML태그 선택하기
document.querySelector(css선택자)



js를 이용하여 속성을 조정 or 스타일 조정

1. 조종하고자 하는 태그를 선택
document.getElementById(아이디값)
document.querySelector(css선택자)

2. 속성값을 조정하거나, style 조정할 수도 있다
대상태그.hasAtribute(속성이름)
대상태그.setAttribute(속성이름,값)
대상태그.getAttribute(속성값)
대상태그.removeAttribute(속성명)


style 조정

1. style객체를 이용환 조정
대상태그.style.
backgroundColor='red'
fontSize
width
height

<style>
    .클래스명{
        스타일
    }
</style>

대상태그.classList.add(클래스명)
대상태그.classList.remove(클래스명)
대상태그.classList.toggle(클래스명) : 있으면 제거, 없으면 추가
대상태그.classList.contains(클래스명) : 대상 클래스가 있는지 확인

3. style.cssText
요소의 모든 인라인 스타일을 문자열 형태로 읽거나 
덮어쓰거나 추가할 수 있는 속성
대상태그.style.cssText = "스타일"

태그의 content부분에 내용넣기

대상태그.innerText = " 안녕하세요"
-순수 텍스트만 넣는다
-태그를 넣으면 그대로 출력된다

대상태그.textContent = "안녕하세요"
-innerText와 유사하지만 DOM 성능이 더 좋다.

대상태그.innerHTML = "storng>강조된 텍스트</strong>"
-html 태그가 실제로 적용
-UI를 동적으로 만들 때 사용

<input value="내용">
input.value ="홍길동"
-input태그.textArea

이벤트
브라우저랑 상호작용하는 모든 행위

클릭, 더블클릭, 마우스올림, 내림, ...


폼 이벤트
focus   : 요소로 포커스가 이동되었을 때 
blur    : 요소에 포커스가 벗어났을 떄
change  : 요소에 값이 변경되었을 때

이벤트가 발생했을 때 어떠 ㄴ행위를 할건지 정하는 걸 '이벤트처리'라고 한다.

이벤트리스너 메서드 사용하기
대상태그.addEventListener()(이벤트 타입, )



html 요소에 스타일을 줄 때도 

1. html 태그를 선택
태그, 클래스, id선택, 속성

2. 스타일을 적용
js를 이용해서 html태그에 스타일을 준다거나, 내용을 추가한다거나 할 때
2-1. html태그를 선택
document.getElementById("아이디값")
document.querySelector("css선택자")
2-2. 이벤트가 발생할 때 html태그를 조정
마우스 관련 이벤트
키보드 관련 이벤트
폼 관련 이벤트
2-3. 이벤트 처리 방법
속성을 이용해서 처리하는 방법
프로퍼티를 이용해서 처리하는 방법
addEventListener("이벤트", 무엇을 하고싶은지)

대상태그.addEventListener("이벤트", function(){
            이벤트가 발생했을 때 뭘 하고싶은지
            }, options
        )


이벤트 흐름의 3단계
브라우저에서 클릭같은 이벤트가 발생하면 내부적으로는 3개의 단계를 거침

1. 캡쳐링 단계
window => document => html => body => ... => 이벤트가 일어난 요소까지 가는 단계

2. 타깃 단계
실제로 이벤트가 발생한 요소에서 이벤트를 처리하는 단계
Ex) 버튼에서 클릭 이벤트가 발생했다

3. 더블링 단계
이벤트가 발생한 요소에서 다시 바깥으로 올라가는 단계
button => div => body =>html => document => widow 형식으로 올라감


이벤트 버블링
이벤트가 "안쪽 요소 => 바깥요소" 방향으로 전파되는 현상
대부분의 경우가 기본값으로 사용되는 이벤트 흐름

버튼에서 발생한 클리깅 위로 올라가면서(parent까지) 부모의 클릭 이벤트도
같이 실행되기 때문


버블링을 막는 방법
event.stopPropagation();

이벤트 캡쳐링
이벤트가 바깥 요소에서 안쪽 요소로 "내려오며" 발생하는 흐름
기본적으로는 잘 안보이지만, 우리가 addEventListenr에서 
설정해주면 사용할 수 있음

addEventListenr 함수에 세 번째 인자 또는 옵션 객체에서 
true를 주게되면 캡쳐링 단계에서 이벤트를 잡을 수 있다.


캡쳐링을 사용하는 경우
페이지 사앋ㄴ에서 몯느 클릭에 대한 로그를 기록하고 싶다.
특정 UI 라이브러리가 내부에서 버블링 전에 먼저 이벤트를
가로채야 한다


이벤트 위임
자식 요소가 너무 많아지게 되고, 자식요소마다 이벤트를 다 주게 되면 비효율적이다.
부모요소한테 이벤트를 위임하고, 실제 이벤트가 발생한 자식 요소에 이벤트 처리를 한다.

Ex) 댓글인데 <ul>로 만들었고 그 안에 <li>가 100개 있다.
댓글은 계속 추가/삭제가 이루어진다.

1. 공통 부모를 선택
const list = document.querySelector("ul");
2. 부모에게 이벤트 핸들러를 등록
* 발생한 이벤트에 관한 정보가 매개변수로 전달이 된다.
list.addEventListener("click", function(event){
   //   여기에 분기 처리 로직을 작성 
});
3. 어떤 자식이 클릭됐는지 확인
- event.target : 실제로 클릭된 가장 안쪽 요소
list.addEventListenr("click", function(event){
    console.log("실제로 클릭된 것 : ", event.target)
    });
4. 조건문 또는 closest()로 필요한 요소만 처리한다
list.addEventListenr("click", function(event){
    const li = event.target.closest("li");

    if(!li || !list.containse(li)){
        //  li가 아니면(또는 ul 바깥이면 무시)
        return;
    }
    //  이벤트 처리
    }
);


우리가 <li>마다 click이벤트를 하나씩 걸다보면...
성능도 비효율적이고 새로 추가된 <li>에는 이벤트가 안걸려서 
js코드를 다시 실행해야 한다는 문제가 있다.
여러 자식에게 각각 이벤트를 달지말고, 
공통 부모에 한 번만 달아서 처리하는 기법

각각의 자식들한테 이벤트 핸들러를 붙이지 않고 공통된 상위부모
요소에 한 번만 이벤트 핸들러를 등록한 뒤 "이벤트 버블링"을 이용해서
"어떤 자식이 눌렀는지" 분기 처리하는 기법이다.


1-1. document.createElement("태그이름")
해당 태그가 만들어지게 된다
const li = document.creatElement("li")
<li></li>
1-2. 내용/속성을 설정
textContent, setAttribute, style
1-3. 부모 요소에 붙이기
대상태그.prepend(태그)
대상 태그의 내부의 첫번째 자식으로 태그가 추가된다

대상태그.append(태그)
대상 태그의 내부의 마지막 자식으로 태그가 추가된다.



ECMAScript : JavaScript의 공식 표준 이름이다.
-   우리가 사용하는 브라우저의(크롬) JS엔진이 ECMAScript 규격을 구현한 것이다.
-   이 표준은 번호로 관리가 된다
    ES1, ES2, ES3, ... ES6
    let, const 

스코프(Scope)
변수가 보이는 범위
-   어디까지 이 변수를 사용할 수 있는지 정해주는 규칙

1. 전역스코프(global)
2.함수스코프(function)
3.블록스코프(block)


호이스팅 (Hoisting)
선언을 위로 끌어올려서 먼저 처리하는 자바스크립트 엔진의 작동 방식
코드를 위에서 아래로 읽는 것처럼 보이지만, 내부적으로 두 단계로 처리한다

1. 준비단계 
-  변수 선언, 함수 선언만 먼저 쭉 훑어서 등록한다
2. 실행단계
-  실제로 한줄씩 실행s

호이스팅에 대해서알아야하는 이유
1. 디버깅 할 때
선언 안했는데 "undefinded"같은 상황을 이해할 수 있다
2. 리팩토링 할 때
선언식 => 표현식으로 바꿀 때
var => let,const로 바꿀 때
어느 부분에서 에러가 날지 에상



화살표 함수
기본적인 함수의 선언
function 함수명(매개변수){
    return 반환값;    
}

함수명(인자)
함수 표현식
const add = function(a,b){
    return a+b;
}


(매개변수) => {함수 본문}

1. 매개변수가 1개면 소괄호를 생략할 수 있다
2. 명령이 return 한줄이면 return키워드와 {}를 같이 생략할 수 있다.


템플릿 리터럴 
","가 아니라 백틱 ``을 사용한다
${}안에 변수를 넣거나, 간단한 연산/함수 호출도 가능하다


디스트럭처링(구조 분해 할당)
배열이나 객체에 들어있는 내용을 꺼내서 변수에 대입하는 것이 번거롭기 때문에
아예 꺼내면서 변수에 넣자

주의해야할 점
1. 객체 분해 할당을 할 떄는 "키 이름"이 정확히 맞아야한다
2. 너무 깊게 중췁해서 한 줄에 다 쓰면 가독성이 떨어진다
-   가볍게 1~2단계까지만 쓰고, 나머지는 변수로 나눠서 사용하는 것이 좋다
3. 함수 인자에서 분해할당 + 기본값을 쓸 때는
function Fn({...}={})와 같이 전체 인자에도 기본값을 넣어주는 패턴을 사용하자



고차함수
함수를 인자로 받거나, 함수를 반환하는 함수
addEventListener("이벤트", 콜백);
배열.map().filter().reduce();
setTimeout(콜백함수, 시간)

1. 함수도 값이다
-   변수도 저장할 수 있다


함수명 프로그래밍 기법
-   함수를 중심으로 코드를  짜는 스타일
-   함수도 변수에 넣거나, 인자로 넘기거나, 반환할 수 있다.

순수함수
같은 값을 입력하면 항상 같은 출력을 내는 것


데이터를 직접 바꾸지 않고 입력 -> 출력이 예측 가능한 순수 함수들로 
작은 함수들을 조합해서 문제를푸는 방식


함수 합성과 파이프라인
-   작은 함수 여러개를 조합해서 큰 기능을 만든다는 느낌이 중요하다



함수형 프로그래밍이 쓰이는 곳
1. 배열 데이터처리 
-   db에서 넘어온 데이터 목록을 가공
-   map, filter, reduce를 조합해서 사용한다
2. React같은 UI프레임워크
-   리액트 내부에서 순수 함수처럼 동작하는 구조를 가진다.
3. 유효성 검사, 데이터 포맷팅, 비즈니스 로직
-   이메일 형식 검사, 비밀번호 규칙 체크, 가격 계산
    등을 작은 순수 함수로 쪼개서 조합하면 유지보수가 쉬워진다.



동기 처리
코드가 위에서 아래로 실행되는 방식
앞의 코드가 끝나야만 뒤 코드가 실행되는 방식
비동기 처리
어떤 작업은 나중에 끝나고, 그 사이에 다른 코드가 먼저 게속 실행되는 방식

대표적인 비동기 함수
setTimeout, setInterval, fetch, XMLHttpRequest



자바스크립트는 싱글 스레드 언어이다.
-   싱글 스레드 : 한번에 하나의 일만 처리할 수 있다
-   한번에 한줄의 코드만 실행
-   오래 걸리는 작업이 있다면 / 멈춘 것처럼 느껴진다면 
-   실제 웹에서는 서버에서 데이터를 가져오는 작업
-   이미지 / 동영상 로딩 / 파일 읽기 / 타이머 / 
-   애니메이션과 같이 오래걸리는 작업이 많다
-
-   위와 같은 작업들은 비동기로 "잠깐 맡겨두고", 나머지 코드를 실행한 후 나중에
-   결과가 준비되면 이어서 처리하는 구조



콜백함수로 비동기 처리하기
나중에 불러달라고 넘겨주는 함수
setTimeout(콜백함수, 시간)
특정 시간 뒤에 콜백함수가 실행된다
특정 시간동안 다른 작업을 먼저 실행한다

비동기작업이 여러 단계로 이어질 때 콜백만 쓰면 코드의 깊이가 너무 깊어지게 되고
가독성이 안좋아진다



Promise 

지금은 없지만, 나중에 생길 값에 대한 약속
지금은 결과를 모르는 작업인데, 나중에 성공하거나 실패하면 알려주는 객체

const p = new Promise(콜백함수)
promise의 상태
Pending : 아직 결과가 안나온 상태
fulfilled : 성공해서 값이 생긴 상태
rejected : 실패해서 에러가 생긴 상태

promise가 호출하는 함수는 resolve와 reject를 매개변수를 받는다
자바스크립트 엔진이 자동으로 resolve함수와 reject함수를 만들어 
매개변수로 넣어준다.

resolve()   : promise의 상태를 fulfilled로 만든다
reject()    : promise의 상태를 rejected로 만든다

한 번 resolve 또는 reject가 호출되어 상태가 결정된다면
그 이후에는 아무리 다시 호출해도 무시된다.

const p = new Promise((resolve, reject) => {
        resolve("첫 번재 성공");
        
        resolve("두 번재 성공");    
        reject("실패");
});

.then() : 성공한 경우 실행되는 함수를 등록하는 메서드


Promise + ten을 사용하는 것은 좋지만, 여전히 콜백의 느낌이 남아있다
그래서 나온 문법이 async/awit

async/await 
Promise기반의 비동기 코드를 동기 코드처럼 읽기 쉽게 만들어주는 문법


try/catch를 이용한 에러 처리 기법
에러가 나도 프로그램이 바로 죽지 않게 잡아줌
try{
    1) 에러가 발생할 수 있는 코드

} catch(error){
    2) 에러가 발생했을 떄 실행되는 코드
}

try 블록에서 에러가 나면 나머지 코드는 건너뛰고, 바로 catch로 점프한다
catch(error)의 매개변수로 에러 정보 객체가 들어오게 된다



fetch()
브라우저에서 제공하는 비동기 HTTP 요청 함수
서버에 데이터를 요청하거나, 서버로 데이터를 보내는 작업을 할 때 사용한다.

fetch()의 특징
1.  Promise 기반이다
-   fetch()는 호출 즉시 Promise객체를 반한한다
-   그렇기 때문에 .then(), .catch()를 사용하거나 async/await으로 처리할 수 있다

fetch(서버의 주소, 옵션)
아무런 옵션 업싱 서버를 호출하면 자동으로 get요청이 된다


HTTP 메서드
클라이언트(사용자)가 서버(제공자)에게 원하는 행동을 정화갛게 전달하는 명령어
GET     - 데이터를 조회
Post    - 서버측에 데이터를 추가(내가 추가하고싶은 데이터를 같이 보낸다)
PUT     - 서버에 있는 데이터를 수정해줘
DELETE  - 서버에 있는 데이터를 삭제


네트워크 오류만 catch된다
HTTP 상태코드 에러(404, 500)가 발생해도 reject되지 않는다.
오직 네트워크가 끊겼을 때만 catch된다

HTTP 상태코드
요청이 얼마나 잘 처리됐는지 서버가 숫자로 알려주는 결과표


200 -> 통신이 잘 됐음

400 -> 요청을 잘못 보냈다
401 -> 누구읹 증명이 안됐다
403 -> 권한이 없음
404 -> 요청 경로가 잘못됨

500 -> 서버에서 발생한 얘기치 못한 오류
502 -> 서버가 다른 서버에 요청을 보냈는데 중간에 문제가 발생한 경우
503 -> 서버가 과부화, 점검, 일시 중단 상태일 때 ( 나중에 다시 시도하기)



JSON(JavaScript Object Notation)
자바스크립트 객체 표기법을 기반으로 마든 데이터 교환 형식
하지만 언어에 상관없이 쓸 수 있는 형식이라서,
자바, 파이썬, 스프링, 노드. 리액트 등 모두 JSON을 이해한다.

웹에서 서버 <-> 브라우저간 통신

key는 무조건 문자열, 쌍따옴표 안에 넣어야 한다.
{"name": "홍길동", "age":25}

value에 올 수 있는 타입
문자열 -> "text"
숫자 -> 10,3.14
논리형 -> true, false
null -> null
객체 -> {...}
배열 -> {...    }

웹 서버와 통신할 때는 fetch를 사용한다
서버가 보내는 응답은 보통 JSON문자열이다
-->